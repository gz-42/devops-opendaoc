name: "Deploy Infra-Update DNS Records"

on:
  workflow_dispatch:
    inputs:
      confirm_deploy:
        description: 'Type "yes" to confirm deployment'
        required: true
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  test-code-security-scan:
    name: "Test Code and Security Scan"
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirm_deploy == 'yes' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          soft_fail: true

      - name: Run checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          soft_fail: true
          framework: terraform

  deploy-and-configure:
    name: "Deploy Infra and Update DNS Records"
    needs: test-code-security-scan
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirm_deploy == 'yes' }}
        
    steps:
      #-----------------------------------------------
      # PHASE 1: TERRAFORM INFRASTRUCTURE DEPLOYMENT
      #-----------------------------------------------
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Create terraform.tfvars
        run: |
          cd terraform
          touch terraform.tfvars
          chmod 644 terraform.tfvars
          cat > terraform.tfvars << EOF
          region = "${{ secrets.AWS_REGION }}"
          project_name = "${{ secrets.PROJECT_NAME }}"
          root_domain_name = "${{ secrets.DOMAIN_NAME }}"
          vpc_cidr = "${{ secrets.VPC_CIDR }}"
          public_subnet_cidrs = ["${{ secrets.VPC_PUBLIC_SUBNETS }}"]
          private_subnet_cidrs = ["${{ secrets.VPC_PRIVATE_SUBNETS }}"]
          cluster_name = "${{ secrets.CLUSTER_NAME }}"
          group_users = ["${{ secrets.GROUP_USERS }}"]
          email = "${{ secrets.EMAIL }}"
          devops_opendaoc_hostname = "${{ secrets.DEVOPS_OPENDAOC_HOSTNAME }}"
          argocd_hostname = "${{ secrets.ARGOCD_HOSTNAME }}"
          mariadb_root_password = "${{ secrets.MARIADB_ROOT_PASSWORD }}"
          db_connection_string = "${{ secrets.DB_CONNECTION_STRING }}"
          grafana_hostname = "${{ secrets.GRAFANA_HOSTNAME }}"
          grafana_pwd = "${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          grafana_tls_secret = "${{ secrets.GRAFANA_TLS_SECRET }}"
          slack_webhook = "${{ secrets.SLACK_WEBHOOK }}"
          slack_channel = "${{ secrets.SLACK_CHANNEL }}"
          EOF
          cd tfstate-init
          touch terraform.tfvars
          chmod 644 terraform.tfvars
          cat > terraform.tfvars << EOF
          region = "${{ secrets.AWS_REGION }}"
          prefix = "${{ secrets.TF_STATE_PREFIX }}"
          dynamodb_table_name = "${{ secrets.TF_STATE_KEY }}"
          EOF
          
      - name: Initialize tfstate infrastructure
        id: init-tfstate
        run: |
          cd terraform
          cd tfstate-init
          terraform init
          terraform apply -auto-approve | grep -v "token\|password\|secret\|key\|cert"
        continue-on-error: true
        
      - name: Terraform Init
        id: init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ secrets.TF_STATE_KEY }}" \
            -backend-config="region=${{ secrets.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"
            
      - name: Terraform Plan
        id: plan
        env:
          TF_CLI_ARGS: "-compact-warnings"
        run: |
          cd terraform
          terraform plan -out=tfplan | grep -v "token\|password\|secret\|key\|cert"
          
      - name: Terraform Apply
        env:
          TF_CLI_ARGS: "-compact-warnings"
        run: |
          cd terraform
          terraform apply -auto-approve tfplan | grep -v "token\|password\|secret\|key\|cert"
      
      - name: Get Load Balancer Hostname
        id: get-lb-hostname
        run: |
          cd terraform
          # Extract the LB hostname from Terraform output
          LB_HOSTNAME=$(terraform output -json | jq -r '.load_balancer_hostname.value')
          
          # Save to environment variable for later steps
          echo "LB_HOSTNAME=$LB_HOSTNAME" >> $GITHUB_ENV
          
          # Mask the value in logs
          echo "::add-mask::$LB_HOSTNAME"
          echo "Load balancer hostname retrieved successfully (value masked)"
      
      #-----------------------------------------------
      # PHASE 2: DNS CONFIGURATION
      #-----------------------------------------------
      - name: Set up Node.js for DNS updates
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: npm install axios
      
      - name: Update DNS Records with CNAME
        run: |
          cat > update_dns.js << 'EOF'
          const axios = require('axios');
          
          async function parseSource(fullHostname, domainName) {
            if (!fullHostname.endsWith(domainName)) {
              throw new Error(`Full hostname doesn't match the domain name`);
            }
            
            return fullHostname.substring(0, fullHostname.length - domainName.length - 1);
          }
          
          async function updateDNSRecord(config, recordData, serviceName) {
            try {
              const source = await parseSource(recordData.fullHostname, config.domainName);
              
              const baseURL = `${config.apiBaseUrl}/${config.domainId}/dns/record`;
              
              const headers = {
                'Authorization': `Bearer ${config.apiToken}`,
                'Content-Type': 'application/json'
              };
              
              const response = await axios.put(`${baseURL}/${recordData.recordId}`, {
                type: 'CNAME',
                source: source,
                target: config.lbHostname,
                ttl: 300
              }, { headers });
              
              console.log(`DNS record updated successfully: ${serviceName}`);
              return true;
            } catch (error) {
              console.error(`Error updating DNS record for ${serviceName}:`, 
                error.response ? error.response.data : error.message);
              return false;
            }
          }
          
          async function updateAllRecords() {
            const config = {
              apiToken: process.env.DNS_API_TOKEN,
              apiBaseUrl: process.env.DNS_API_BASE_URL,
              domainId: process.env.DOMAIN_ID,
              domainName: process.env.DOMAIN_NAME,
              lbHostname: process.env.LB_HOSTNAME
            };
            
            const records = [
              {
                fullHostname: process.env.GRAFANA_HOSTNAME,
                recordId: process.env.GRAFANA_RECORD_ID,
                serviceName: 'Grafana'
              },
              {
                fullHostname: process.env.ARGOCD_HOSTNAME,
                recordId: process.env.ARGOCD_RECORD_ID,
                serviceName: 'ArgoCD'
              },
              {
                fullHostname: process.env.DEVOPS_OPENDAOC_HOSTNAME,
                recordId: process.env.DEVOPS_OPENDAOC_RECORD_ID,
                serviceName: 'DevOps OpenDAoC'
              }
            ];
            
            const requiredConfig = ['apiToken', 'apiBaseUrl', 'domainId', 'domainName', 'lbHostname'];
            for (const field of requiredConfig) {
              if (!config[field]) {
                console.error(`Missing required configuration: ${field}`);
                process.exit(1);
              }
            }
            
            let successCount = 0;
            let failCount = 0;
            
            for (const record of records) {
              if (!record.recordId || !record.fullHostname) {
                console.error(`Missing record information for ${record.serviceName}`);
                failCount++;
                continue;
              }
              
              const success = await updateDNSRecord(
                config,
                record,
                record.serviceName
              );
              
              if (success) {
                successCount++;
              } else {
                failCount++;
              }
            }
            
            console.log(`DNS update summary: ${successCount} successful, ${failCount} failed`);
            
            if (failCount > 0) {
              process.exit(1);
            }
          }
          
          updateAllRecords();
          EOF
          
          node update_dns.js
        env:
          DNS_API_TOKEN: ${{ secrets.DNS_API_TOKEN }}
          DNS_API_BASE_URL: ${{ secrets.DNS_API_BASE_URL }}
          DOMAIN_ID: ${{ secrets.DOMAIN_ID }}
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          LB_HOSTNAME: ${{ env.LB_HOSTNAME }}
          GRAFANA_HOSTNAME: ${{ secrets.GRAFANA_HOSTNAME }}
          GRAFANA_RECORD_ID: ${{ secrets.GRAFANA_RECORD_ID }}
          ARGOCD_HOSTNAME: ${{ secrets.ARGOCD_HOSTNAME }}
          ARGOCD_RECORD_ID: ${{ secrets.ARGOCD_RECORD_ID }}
          DEVOPS_OPENDAOC_HOSTNAME: ${{ secrets.DEVOPS_OPENDAOC_HOSTNAME }}
          DEVOPS_OPENDAOC_RECORD_ID: ${{ secrets.DEVOPS_OPENDAOC_RECORD_ID }}
          
      - name: Output DNS Update Results
        run: |
          echo "Updated DNS records to point to the Load Balancer (hostname masked):"
          echo "- Grafana"
          echo "- ArgoCD"
          echo "- DevOps OpenDAoC"
          echo "DNS changes may take some time to propagate based on TTL settings."
      
      #-----------------------------------------------
      # PHASE 3: CLEANUP
      #-----------------------------------------------
      - name: Cleanup sensitive files
        if: always()
        run: |
          cd terraform
          rm -f tfplan
          rm -f crash.log
          rm -f terraform.tfstate*
          rm -f terraform.tfvars
          cd tfstate-init
          rm -f tfplan
          rm -f crash.log
          rm -f terraform.tfstate*
          rm -f terraform.tfvars
